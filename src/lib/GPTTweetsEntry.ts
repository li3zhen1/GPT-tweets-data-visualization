// Generated by https://quicktype.io

// import * as csv from "csv";
import _ from "lodash";
import * as d3 from "d3";



export const emotionKeys = [
    "disappointment",
    "sadness",
    "annoyance",
    "neutral",
    "disapproval",
    "nervousness",
    "realization",
    "approval",
    "joy",
    "remorse",
    "caring",
    "embarrassment",
    "anger",
    "disgust",
    "grief",
    "confusion",
    "relief",
    "desire",
    "admiration",
    "fear",
    "optimism",
    "love",
    "excitement",
    "curiosity",
    "amusement",
    "surprise",
    "gratitude",
    "pride",
] as const;

export const emotionScores: any = {
    "disappointment": 0.2,
    "sadness": 0.1,
    "annoyance": 0.3,
    "neutral": 0.5,
    "disapproval": 0.3,
    "nervousness": 0.3,
    "realization": 0.6,
    "approval": 0.7,
    "joy": 1.0,
    "remorse": 0.2,
    "caring": 0.8,
    "embarrassment": 0.2,
    "anger": 0.1,
    "disgust": 0.1,
    "grief": 0.1,
    "confusion": 0.4,
    "relief": 0.8,
    "desire": 0.6,
    "admiration": 0.9,
    "fear": 0.1,
    "optimism": 0.9,
    "love": 1.0,
    "excitement": 0.9,
    "curiosity": 0.7,
    "amusement": 0.9,
    "surprise": 0.5,
    "gratitude": 0.9,
    "pride": 0.8
}


export type EmotionKey = typeof emotionKeys[number]


export type TweetDataRow = {
    date: Date;// | null;
    text: string;
    user_name: string;
    user_location: string;
    user_description: string;
    user_created: string;
    user_followers: number;
    user_friends: number;
    user_favourites: number;
    user_verified: boolean;
    hashtags: string[];
    source: string;
} & Record<EmotionKey, number>


export function parseDateField(dateText: string): Date | null {
    // parse "2023-04-03 22:26:13+00:00" into a Date object
    return d3.timeParse("%Y-%m-%d %H:%M:%S%Z")(dateText);
}

let regex = /'([^']*)'/g;
export function parsePythonStrArrayField(text: string): string[] {
    // `['a', 'b', 'c']` -> ["a", "b", "c"]
    let result: string[] = [];
    let match;
    while ((match = regex.exec(text))) {
        result.push(match[1].toLowerCase());
    }
    return result;
}


export async function loadTweetData(): Promise<TweetDataRow[]> {
    return await fetch("GPTTtweets_processed_with_emotions.json").then(
        async it => {
            let entry = await it.json();
            entry.forEach((data: any) => {
                data.date = parseDateField(data.date);
                for (const key of emotionKeys) {
                    data[key] = parseFloat(data[key]);
                }
                data['hashtags'] = parsePythonStrArrayField(data['hashtags']);
            });
            return entry;
        }
    )
}


export function groupByHashTag(
    data: TweetDataRow[],
    topN: number = 20
): [string, TweetDataRow[]][] {

    const results: Record<string, TweetDataRow[]> = {};

    for (const row of data) {
        for (const tag of row.hashtags) {
            // const tag = _tag.toLocaleLowerCase();
            if (!results[tag]) {
                results[tag] = [];
            }
            results[tag].push(row);
        }
    }

    const counts = _.countBy(data.flatMap(row => row.hashtags));
    const sorted = _.sortBy(Object.entries(counts), ([tag, count]) => -count);


    const result = sorted.slice(0, topN).map(([tag, count]) => [tag, results[tag]]) as any;
    // console.log(result)
    return result;

}

export function groupByMaxEmotion(
    data: TweetDataRow[],
    topN: number = 20
): [string, TweetDataRow[]][] {
    const results: Record<string, TweetDataRow[]> = {};

    for (const row of data) {
        const maxEmotion = _.maxBy(emotionKeys, key => row[key])!;
        if (!results[maxEmotion]) {
            results[maxEmotion] = [];
        }
        results[maxEmotion].push(row);
    }

    const counts = _.countBy(data.map(row => _.maxBy(emotionKeys, key => row[key])!));

    const sorted = _.sortBy(Object.entries(counts), ([tag, count]) => emotionScores[tag] ?? 0);

    const result = sorted.slice(0, topN).map(([tag, count]) => [tag, results[tag]]) as any;

    return result;
}

export function binByDay(data: TweetDataRow[]): Record<string, TweetDataRow[]> {
    const results: Record<string, TweetDataRow[]> = {};

    for (const row of data) {
        const date = row.date;
        if (date) {
            const key = d3.timeFormat("%Y-%m-%d")(date);
            if (!results[key]) {
                results[key] = [];
            }
            results[key].push(row);
        }
    }

    return results;
}


export type BinnedCounts = [string, {
    x: number;
    count: number;
}[]][];


export function stackByBinnedHashTag(
    groupedData: [string, TweetDataRow[]][],
    xScale: d3.ScaleTime<number, number, never>,
    minDate: Date,
    maxDate: Date
): {
    unstacked: BinnedCounts;
    stacked: BinnedCounts;
} {
    const bin: d3.HistogramGeneratorDate<TweetDataRow, Date> = d3
        .bin<TweetDataRow, Date>()
        .value((d) => d.date!)
        .domain([minDate, maxDate])
        .thresholds(xScale.ticks(80));

    const unstacked = groupedData.map(([tag, data], i) => {
        const histogram = bin(data);
        const counts = histogram.map((bin) => ({
            x: xScale(bin.x0!),
            count: bin.length,
        }));
        return [tag, counts] as [string, {
            x: number;
            count: number;
        }[]];
    });

    const stacked = _.cloneDeep(unstacked);

    for (let nthKey = stacked.length - 1; nthKey >= 0; nthKey--) {
        for (let i = 0; i < stacked[nthKey][1].length; i++) {
            stacked[nthKey][1][i].count += (stacked[nthKey + 1]?.[1][i]?.count || 0);
        }
    }

    for (let nthKey = stacked.length - 1; nthKey >= 0; nthKey--) {
        for (let i = 0; i < stacked[nthKey][1].length; i++) {
            if (stacked[0][1][i].count === 0) {
                stacked[nthKey][1][i].count = 0;
            }
            else {
                stacked[nthKey][1][i].count /= (stacked[0][1][i].count);
            }
        }
    }
    // console.log(stacked[0], unstacked[0])
    return { unstacked, stacked };
}

// export function stackByBinnedEmotion(
//     groupedData: [string, TweetDataRow[]][],
//     xScale: d3.ScaleTime<number, number, never>,
//     minDate: Date,
//     maxDate: Date
// ): {
//     unstacked: BinnedCounts;
//     stacked: BinnedCounts;
// } {
//     const bin: d3.HistogramGeneratorDate<TweetDataRow, Date> = d3
//         .bin<TweetDataRow, Date>()
//         .value((d) => d.date!)
//         .domain([minDate, maxDate])
//         .thresholds(xScale.ticks(80));

    
//     const unstacked = groupedData.map(([tag, data], i) => {

//     const stacked = _.cloneDeep(unstacked);

//     for (let nthKey = stacked.length - 1; nthKey >= 0; nthKey--) {
//         for (let i = 0; i < stacked[nthKey][1].length; i++) {
//             stacked[nthKey][1][i].count += (stacked[nthKey + 1]?.[1][i]?.count || 0);
//         }
//     }

//     for (let nthKey = stacked.length - 1; nthKey >= 0; nthKey--) {
//         for (let i = 0; i < stacked[nthKey][1].length; i++) {
//             if (stacked[0][1][i].count === 0) {
//                 stacked[nthKey][1][i].count = 0;
//             }
//             else {
//                 stacked[nthKey][1][i].count /= (stacked[0][1][i].count);
//             }
//         }
//     }
//     // console.log(stacked[0], unstacked[0])
//     return { unstacked, stacked };

// }
